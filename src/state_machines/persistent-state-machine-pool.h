#ifndef PERSISTENT_STATE_MACHINE_POOL_H
#define PERSISTENT_STATE_MACHINE_POOL_H

#include <iostream>
#include <map>
#include <limits>
#include <queue>
#include <set>
#include <utility>

#include <boost/shared_ptr.hpp>

#include "base/macros.h"
#include "state_machines/state-machine-pool.h"

namespace polar_express {

// A state machine pool for state machines that are persistent. That is, once
// started, they can be fed input indefinitely until explicitly terminated. The
// state machines will be terminated when there is no more work for them to do,
// that is, when none are active, and the input queue is empty, and the
// preceding pool (if any) is also idle.
//
// The StateMachineT type must provide a method SetDoneCallback(Callback) which
// has the normal StateMachine semantics, and a method FinishAndExit which
// causes the state machine to finish processing any pending input, and then
// terminate, invoking the done callback. There are no other restrictions on the
// properties of the template types.
//
// This is an abstract base class. There must be a specialization for each
// StateMachineT type which at least provides an appropriate wrapper for the
// call to the state machine type's Start method, and method to run inputs,
// since the start method will take parameters that depend on the state machine
// type and the method for running inputs may be named differently on different
// state machines. The derived class may also handle additional type-specific
// callbacks for the state machine.
template <typename StateMachineT, typename InputT>
class PersistentStateMachinePool : public StateMachinePool<InputT> {
 public:
  virtual ~PersistentStateMachinePool();

  virtual size_t ActiveOutputWeightOutstanding() const;

  virtual const char* name() const = 0;

 protected:
  PersistentStateMachinePool(
      boost::shared_ptr<AsioDispatcher::StrandDispatcher> strand_dispatcher,
      size_t max_pending_inputs, size_t max_simultaneous_state_machines,
      boost::shared_ptr<StateMachinePoolBase> preceding_pool =
          boost::shared_ptr<StateMachinePoolBase>());

  virtual void StartNewStateMachine(
      boost::shared_ptr<StateMachineT> state_machine) = 0;

  virtual void RunInputOnStateMachine(
      boost::shared_ptr<InputT> input,
      boost::shared_ptr<StateMachineT> state_machine) = 0;

  // Optional override if the derived class needs to do any special handling on
  // a finished state machine.
  virtual void HandleStateMachineFinishedInternal(
      boost::shared_ptr<StateMachineT> state_machine) {}

  // Deactivates the current state machine, and then tries to run the next
  // available state machine if possible. It is necessary to go through these
  // two steps in sequence, rather than just trying to run the next input on the
  // given already-active state machine because this pool may need to wait for
  // the next pool to have available input slots.
  void DeactivateStateMachineAndTryRunNext(
      boost::shared_ptr<StateMachineT> state_machine);

 protected:
  void StateMachineProducedOutput(
      boost::shared_ptr<StateMachineT> state_machine,
      size_t output_weight_remaining);

  // Derived classes must implement. The return value should be independent of
  // any still-pending output weight on any state machine.
  virtual size_t OutputWeightToBeAddedByInputInternal(
      boost::shared_ptr<InputT> input) const = 0;

  // Derived classes may override to provide a limit on the amount of output
  // weight that can possibly be generated by any one input. This makes sense if
  // the persistent state machine can retain more pending output weight across
  // outputs than it can possibly produce in a single output.
  virtual size_t MaxOutputWeightGeneratedByAnyInput() const {
    return std::numeric_limits<size_t>::max();
  }

  // Pools for state machines that may retain partial input after producing
  // output can override this method if they want to try to continue working on
  // retained input before receiving new input. This method should return true
  // if the given state machine CANNOT be continued, and needs new input.
  virtual bool TryContinue(
      boost::shared_ptr<StateMachineT> state_machine) {
    return false;
  }

 private:
  virtual size_t OutputWeightToBeAddedByInput(
      boost::shared_ptr<InputT> input) const;

  virtual size_t NumRunningStateMachines() const;

  virtual bool IsCompletelyIdleInternal() const;

  virtual void TryRunNextStateMachineInternal();

  boost::shared_ptr<StateMachineT> TryActivateStateMachine();

  void DeactivateStateMachine(
      boost::shared_ptr<StateMachineT> state_machine);

  void TryRunNextInput(boost::shared_ptr<StateMachineT> state_machine);

  void HandleStateMachineFinished(
      boost::shared_ptr<StateMachineT> state_machine);

  void TerminateStateMachine(boost::shared_ptr<StateMachineT> state_machine);

  void TerminateAllStateMachinesWithNoPendingOutput();

  std::queue<boost::shared_ptr<InputT> > pending_inputs_;
  std::queue<boost::shared_ptr<StateMachineT> > idle_state_machines_;
  std::set<boost::shared_ptr<StateMachineT> > active_state_machines_;
  std::set<boost::shared_ptr<StateMachineT> > terminated_state_machines_;
  std::map<const StateMachineT*, size_t> output_weight_outstanding_;
  size_t active_output_weight_outstanding_;

  DISALLOW_COPY_AND_ASSIGN(PersistentStateMachinePool);
};

template <typename StateMachineT, typename InputT>
PersistentStateMachinePool<StateMachineT, InputT>::PersistentStateMachinePool(
    boost::shared_ptr<AsioDispatcher::StrandDispatcher> strand_dispatcher,
    size_t max_pending_inputs, size_t max_simultaneous_state_machines,
    boost::shared_ptr<StateMachinePoolBase> preceding_pool)
    : StateMachinePool<InputT>(strand_dispatcher, max_pending_inputs,
                               max_simultaneous_state_machines,
                               preceding_pool),
      active_output_weight_outstanding_(0) {
}

template <typename StateMachineT, typename InputT>
PersistentStateMachinePool<StateMachineT, InputT>::
~PersistentStateMachinePool() {
}

template <typename StateMachineT, typename InputT>
size_t PersistentStateMachinePool<
    StateMachineT, InputT>::ActiveOutputWeightOutstanding() const {
  return active_output_weight_outstanding_;
}

template <typename StateMachineT, typename InputT>
void PersistentStateMachinePool<StateMachineT,
                                InputT>::DeactivateStateMachineAndTryRunNext(
    boost::shared_ptr<StateMachineT> state_machine) {
  DeactivateStateMachine(state_machine);
  StateMachinePool<InputT>::TryRunNextStateMachine();
}

template <typename StateMachineT, typename InputT>
void
PersistentStateMachinePool<StateMachineT, InputT>::StateMachineProducedOutput(
    boost::shared_ptr<StateMachineT> state_machine,
    size_t output_weight_remaining) {
  // Terminated machines get special treatment because their output is not in
  // response to input, so may exceed the output weight outstanding for the
  // machine.
  if (terminated_state_machines_.find(state_machine) !=
      terminated_state_machines_.end()) {
    active_output_weight_outstanding_ -=
        output_weight_outstanding_[state_machine.get()];
    output_weight_outstanding_.erase(state_machine.get());
  } else {
    assert(output_weight_outstanding_[state_machine.get()] >=
           output_weight_remaining);
    const size_t output_weight_produced =
        output_weight_outstanding_[state_machine.get()] -
        output_weight_remaining;
    output_weight_outstanding_[state_machine.get()] = output_weight_remaining;

    assert(active_output_weight_outstanding_ >= output_weight_produced);
    active_output_weight_outstanding_ -= output_weight_produced;
  }
}

template <typename StateMachineT, typename InputT>
size_t
PersistentStateMachinePool<StateMachineT, InputT>::OutputWeightToBeAddedByInput(
    boost::shared_ptr<InputT> input) const {
  size_t output_weight = OutputWeightToBeAddedByInputInternal(input);
  if (!idle_state_machines_.empty()) {
    const auto itr =
        output_weight_outstanding_.find(idle_state_machines_.front().get());
    if (itr != output_weight_outstanding_.end()) {
      output_weight += itr->second;
    }

  }
  return std::min(MaxOutputWeightGeneratedByAnyInput(), output_weight);
}

template <typename StateMachineT, typename InputT>
size_t PersistentStateMachinePool<StateMachineT,
                                  InputT>::NumRunningStateMachines() const {
  return active_state_machines_.size();
}

template <typename StateMachineT, typename InputT>
bool PersistentStateMachinePool<StateMachineT,
                                InputT>::IsCompletelyIdleInternal() const {
  return active_state_machines_.empty();
}

template <typename StateMachineT, typename InputT>
void PersistentStateMachinePool<StateMachineT,
                                InputT>::TryRunNextStateMachineInternal() {
  DLOG(std::cerr << name() << " trying to activate state machine. Idle = "
       << idle_state_machines_.size() << ", Active = "
       << active_state_machines_.size() << ", Terminated = "
       << terminated_state_machines_.size() << "." << std::endl);
  boost::shared_ptr<StateMachineT> activated_state_machine =
      TryActivateStateMachine();

  if (activated_state_machine != nullptr) {
    DLOG(std::cerr << name() << " activated state machine "
                   << activated_state_machine.get() << "." << std::endl);
    if (!TryContinue(activated_state_machine)) {
      TryRunNextInput(activated_state_machine);
    } else {
      DLOG(std::cerr << name() << " continued state machine "
                     << activated_state_machine.get() << "." << std::endl);
    }
  } else {
    DLOG(std::cerr << name() << " could not activate a state machine."
                   << std::endl);
  }

  DLOG(std::cerr
       << name() << " finished TryRunNextStateMachineInternal. Idle = "
       << idle_state_machines_.size()
       << ", Active = " << active_state_machines_.size() << ", Terminated = "
       << terminated_state_machines_.size() << "." << std::endl);
}

template <typename StateMachineT, typename InputT>
boost::shared_ptr<StateMachineT>
PersistentStateMachinePool<StateMachineT, InputT>::TryActivateStateMachine() {
  boost::shared_ptr<StateMachineT> activated_state_machine;
  if (!idle_state_machines_.empty()) {
    activated_state_machine = idle_state_machines_.front();
    idle_state_machines_.pop();
  } else if (active_state_machines_.size() + terminated_state_machines_.size() <
             this->max_simultaneous_state_machines()) {
    activated_state_machine.reset(new StateMachineT);
    activated_state_machine->SetDoneCallback(
        this->CreateStrandCallback(
            bind(&PersistentStateMachinePool<
                     StateMachineT, InputT>::HandleStateMachineFinished,
                 this, activated_state_machine)));
    output_weight_outstanding_.insert(
        make_pair(activated_state_machine.get(), 0));
    StartNewStateMachine(activated_state_machine);
  }

  if (activated_state_machine != nullptr) {
    active_state_machines_.insert(activated_state_machine);
    active_output_weight_outstanding_ +=
        output_weight_outstanding_[activated_state_machine.get()];
  }
  return activated_state_machine;
}

template <typename StateMachineT, typename InputT>
void PersistentStateMachinePool<StateMachineT, InputT>::DeactivateStateMachine(
    boost::shared_ptr<StateMachineT> state_machine) {
  assert(state_machine != nullptr);
  if(active_state_machines_.find(state_machine) !=
     active_state_machines_.end()) {
    active_state_machines_.erase(state_machine);
    assert(active_output_weight_outstanding_ >=
           output_weight_outstanding_[state_machine.get()]);
    active_output_weight_outstanding_ -=
        output_weight_outstanding_[state_machine.get()];

    if (terminated_state_machines_.find(state_machine) ==
        terminated_state_machines_.end()) {
      if (this->IsCompletelyIdleAndNotExpectingMoreInput()) {
        TerminateStateMachine(state_machine);
      } else {
        idle_state_machines_.push(state_machine);
      }
    } else {
      DLOG(std::cerr << name() << " is not returning state machine "
                     << state_machine.get()
                     << " to the idle pool because it is being terminated."
                     << std::endl);
    }

    DLOG(std::cerr
         << name() << " deactivated state machine " << state_machine.get()
         << ". Idle = " << idle_state_machines_.size()
         << ", Active = " << active_state_machines_.size() << ", Terminated = "
         << terminated_state_machines_.size() << "." << std::endl);
  }
}

template <typename StateMachineT, typename InputT>
void PersistentStateMachinePool<StateMachineT, InputT>::TryRunNextInput(
    boost::shared_ptr<StateMachineT> state_machine) {
  assert(state_machine != nullptr);

  boost::shared_ptr<InputT> input = this->PopNextInput();
  if (input != nullptr) {
    const size_t output_weight = OutputWeightToBeAddedByInput(input);
    output_weight_outstanding_[state_machine.get()] += output_weight;
    active_output_weight_outstanding_ += output_weight;
    RunInputOnStateMachine(input, state_machine);
  } else {
    DeactivateStateMachine(state_machine);
  }

  if (this->IsCompletelyIdleAndNotExpectingMoreInput()) {
    DLOG(std::cerr << name() << " is done and will terminate all state "
                                "machines with no pending output. "
                   << std::endl);
    TerminateAllStateMachinesWithNoPendingOutput();
  }
}

template <typename StateMachineT, typename InputT>
void
PersistentStateMachinePool<StateMachineT, InputT>::HandleStateMachineFinished(
    boost::shared_ptr<StateMachineT> state_machine) {
  DLOG(std::cerr << name()
                 << " is informed of the termination of state machine "
                 << state_machine.get() << "." << std::endl);
  HandleStateMachineFinishedInternal(state_machine);

  // Presistent state machines by definition are not restartable. They only
  // finish when explicitly terminated, So the state machine should not return
  // to the idle pool.
  active_state_machines_.erase(state_machine);

  if (this->IsCompletelyIdleAndNotExpectingMoreInput()) {
    DLOG(std::cerr << name() << " is done and will terminate all state "
                                "machines with no pending output. "
                   << std::endl);
    TerminateAllStateMachinesWithNoPendingOutput();
  }
}

template <typename StateMachineT, typename InputT>
void PersistentStateMachinePool<StateMachineT, InputT>::TerminateStateMachine(
    boost::shared_ptr<StateMachineT> state_machine) {
  // Prevent the machine from returning to the idle pool.
  active_state_machines_.insert(state_machine);
  terminated_state_machines_.insert(state_machine);

  DLOG(std::cerr << name() << " is instructing state machine "
                 << state_machine.get() << " to terminate." << std::endl);
  state_machine->FinishAndExit();
}

template <typename StateMachineT, typename InputT>
void PersistentStateMachinePool<
    StateMachineT, InputT>::TerminateAllStateMachinesWithNoPendingOutput() {
  std::queue<boost::shared_ptr<StateMachineT> >
      state_machines_with_pending_output;
  while (!idle_state_machines_.empty()) {
    boost::shared_ptr<StateMachineT> state_machine =
        idle_state_machines_.front();
    idle_state_machines_.pop();

    if (output_weight_outstanding_[state_machine.get()] == 0) {
      TerminateStateMachine(state_machine);
    } else {
      state_machines_with_pending_output.push(state_machine);
    }
  }
  idle_state_machines_.swap(state_machines_with_pending_output);
}

}  // namespace polar_express

#endif  // PERSISTENT_STATE_MACHINE_POOL_H
