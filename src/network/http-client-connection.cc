#include "network/http-client-connection.h"

#include <algorithm>
#include <sstream>

#include <boost/algorithm/string.hpp>
#include <boost/bind.hpp>

#include "base/make-unique.h"
#include "network/ssl-connection.h"
#include "network/tcp-connection.h"
#include "proto/http.pb.h"

namespace polar_express {
namespace {

const char kHttpProtocol[] = "http";
const char kHttpsProtocol[] = "https";

const char* GetMethodString(HttpRequest::Method method) {
  switch (method) {
    case HttpRequest::GET:
      return "GET";
    case HttpRequest::PUT:
      return "PUT";
    case HttpRequest::POST:
      return "POST";
    case HttpRequest::DELETE:
      return "DELETE";
    default:
      assert(false);
      return "";
  }
}

bool MethodRequiresContentLength(HttpRequest::Method method) {
  switch (method) {
    case HttpRequest::PUT:
    case HttpRequest::POST:
      return true;
    case HttpRequest::GET:
    case HttpRequest::DELETE:
      return false;
    default:
      assert(false);
      return false;
  }
}

}  // namespace

HttpClientConnection::HttpClientConnection()
    : HttpClientConnection(make_unique<TcpConnection>()) {
}

HttpClientConnection::HttpClientConnection(
    unique_ptr<StreamConnection>&& stream_connection)
    : HttpConnection(std::move(stream_connection)),
      request_pending_(false),
      last_request_succeeded_(false) {
}

HttpClientConnection::~HttpClientConnection() {
}

const string& HttpClientConnection::hostname() const {
  return stream_connection().hostname();
}

const string& HttpClientConnection::protocol() const {
  return stream_connection().protocol();
}

bool HttpClientConnection::last_request_succeeded() const {
  return last_request_succeeded_;
}

bool HttpClientConnection::Open(
    AsioDispatcher::NetworkUsageType network_usage_type,
    const string& hostname, Callback callback) {
  ResetStrandDispatcher(network_usage_type);
  return stream_connection().Open(network_usage_type, hostname,
                                  is_secure() ? kHttpsProtocol : kHttpProtocol,
                                  callback);
}

bool HttpClientConnection::Reopen(Callback callback) {
  if (is_open()) {
    return false;
  }
  return stream_connection().Reopen(callback);
}

bool HttpClientConnection::SendRequest(
    const HttpRequest& request, const vector<byte>* request_payload,
    HttpResponse* response, vector<byte>* response_payload,
    Callback callback) {
  return SendRequest(request, vector<const vector<byte>*>({request_payload}),
                     response, response_payload, callback);
}

bool HttpClientConnection::SendRequest(
    const HttpRequest& request,
    const vector<const vector<byte>*>& request_sequential_payload,
    HttpResponse* response, vector<byte>* response_payload, Callback callback) {
  if (!is_open() || request_pending_) {
    return false;
  }

  // Refuse to send requests specifying a secure connection over an insecure
  // connection (but the reverse is fine).
  if (request.is_secure() && !is_secure()) {
    return false;
  }

  request_pending_ = true;

  // sequential_data will hold the headers generated by serializing the HTTP
  // Request, followed by the request sequential payload.
  vector<const vector<byte>*> sequential_data;
  sequential_data.reserve(request_sequential_payload.size() + 1);

  // Insert a placeholder for the serialized request (generated below);
  sequential_data.push_back(nullptr);

  size_t total_payload_size = 0;
  for (const auto* buf : request_sequential_payload) {
    if (buf != nullptr) {
      sequential_data.push_back(buf);
      total_payload_size += buf->size();
    }
  }

  SerializeRequest(request, total_payload_size);
  sequential_data[0] = serialized_request_.get();

  CHECK_NOTNULL(response)->Clear();
  if (response_payload == nullptr) {
    tmp_response_payload_.reset(new vector<byte>);
    response_payload = tmp_response_payload_.get();
  }

  Callback request_sent_callback = CreateStrandCallback(
      boost::bind(&HttpClientConnection::RequestSent, this,
                  response, response_payload, callback));
  if (stream_connection().WriteAll(sequential_data, request_sent_callback)) {
    return true;
  }

  CleanUpRequestState();
  return false;
}

void HttpClientConnection::SerializeRequest(
    const HttpRequest& request, size_t payload_size) {
  const char* const method = GetMethodString(request.method());
  const string& hostname =
      request.hostname().empty() ? this->hostname() : request.hostname();

  string query_parameters;
  BuildQueryParameters(request, &query_parameters);

  string request_headers;
  BuildRequestHeaders(request, &request_headers);

  ostringstream serialized_request_sstr;
  serialized_request_sstr << method << " " << request.path();
  if (!query_parameters.empty()) {
    serialized_request_sstr << "?" << query_parameters;
  }
  serialized_request_sstr << " HTTP/1.1\r\n"
                          << "Host: " << hostname << "\r\n";
  if (!request_headers.empty()) {
    serialized_request_sstr << request_headers << "\r\n";
  }
  if (payload_size > 0 || MethodRequiresContentLength(request.method())) {
    serialized_request_sstr << "Content-Length: " << payload_size << "\r\n";
  }
  serialized_request_sstr << "\r\n";

  const string& serialized_request_str = serialized_request_sstr.str();
  serialized_request_.reset(new vector<byte>(
      serialized_request_str.begin(), serialized_request_str.end()));
}

void HttpClientConnection::BuildQueryParameters(
    const HttpRequest& request, string* query_parameters) const {
  vector<string> parameter_pairs;
  for (const auto& kv : request.query_parameters()) {
    parameter_pairs.push_back(
        UriEncode(kv.key()) + "=" + UriEncode(kv.value()));
  }

  *CHECK_NOTNULL(query_parameters) = algorithm::join(parameter_pairs, "&");
}

void HttpClientConnection::BuildRequestHeaders(
    const HttpRequest& request, string* request_headers) const {
  SerializeHeaders(request.request_headers(), {"Host", "Content-Length"},
                   request_headers);
}

bool HttpClientConnection::DeserializeResponse(HttpResponse* response) {
  assert(response != nullptr);
  const vector<byte>::const_iterator serialized_response_end_itr =
      serialized_response_->end();
  vector<byte>::const_iterator serialized_response_itr =
      serialized_response_->begin();

  response->set_transport_succeeded(true);
  response->set_is_secure(is_secure());

  string status_line;
  serialized_response_itr = GetTextLineFromData(
      serialized_response_itr, serialized_response_end_itr, &status_line);
  ParseResponseStatus(status_line, response);

  ParseResponseHeaders(
      serialized_response_itr, serialized_response_end_itr, response);

  return true;
}

void HttpClientConnection::ParseResponseHeaders(
    vector<byte>::const_iterator begin,
    vector<byte>::const_iterator end,
    HttpResponse* response) const {
  DeserializeHeadersFromData(
      begin, end, CHECK_NOTNULL(response)->mutable_response_headers());
}

void HttpClientConnection::ParseResponseStatus(
    const string& status_line, HttpResponse* response) const {
  assert(response != nullptr);
  istringstream status_line_sstr(status_line);
  string http_version;
  int status_code = 0;

  // TODO: Error handling?
  status_line_sstr >> http_version >> status_code;

  vector<string> version_parts;
  split(version_parts, http_version, is_any_of("/"));
  if (version_parts.size() >= 2) {
    response->set_http_version(version_parts[1]);
  }

  response->set_status_code(status_code);
  response->set_status_phrase(
      status_line_sstr.eof()  ?  "" :
      algorithm::trim_left_copy(
          status_line_sstr.str().substr(status_line_sstr.tellg())));
}

const string& HttpClientConnection::GetResponseHeaderValue(
    const HttpResponse& response, const string& key) const {
  return GetHeaderValue(response.response_headers(), key);
}

bool HttpClientConnection::IsResponsePayloadChunked(
    const HttpResponse& response) const {
  return IsPayloadChunked(response.response_headers());
}

size_t HttpClientConnection::GetResponsePayloadSize(
    const HttpResponse& response) const {
  return GetPayloadSize(response.response_headers());
}

void HttpClientConnection::RequestSent(
    HttpResponse* response, vector<byte>* response_payload,
    Callback send_request_callback) {
  bool still_ok = false;
  if (stream_connection().last_write_succeeded()) {
    Callback response_received_callback = CreateStrandCallback(
        boost::bind(&HttpClientConnection::ResponseReceived, this,
                    response, response_payload, send_request_callback));
    serialized_response_.reset(new vector<byte>);
    still_ok = stream_connection().ReadUntil(
        { '\r', '\n', '\r', '\n' }, serialized_response_.get(),
        response_received_callback);
  }

  if (!still_ok) {
    HandleRequestError(response, send_request_callback);
  }
}

void HttpClientConnection::ResponseReceived(
    HttpResponse* response, vector<byte>* response_payload,
    Callback send_request_callback) {
  bool still_ok = false;
  if (stream_connection().last_read_succeeded() &&
      DeserializeResponse(response)) {
    if (IsResponsePayloadChunked(*response)) {
      Callback response_payload_chunk_header_received_callback =
          CreateStrandCallback(
              boost::bind(
                  &HttpClientConnection::ResponsePayloadChunkHeaderReceived,
                  this, response, response_payload, send_request_callback));
      response_payload_chunk_buffer_.reset(new vector<byte>);
      still_ok = stream_connection().ReadUntil(
          { '\r', '\n' }, response_payload_chunk_buffer_.get(),
          response_payload_chunk_header_received_callback);
    } else {
      Callback response_payload_received_callback = CreateStrandCallback(
          boost::bind(&HttpClientConnection::ResponsePayloadReceived, this,
                      response, response_payload, send_request_callback));

      // Ask to read, even if the payload size is zero, to simplify
      // callback handling (so that ResponsePayloadRecieved is always
      // the last callback in a successful response.)
      still_ok = stream_connection().ReadSize(
          GetResponsePayloadSize(*response),
          response_payload, response_payload_received_callback);
    }
  }

  if (!still_ok) {
    HandleRequestError(response, send_request_callback);
  }
}

void HttpClientConnection::ResponsePayloadChunkHeaderReceived(
    HttpResponse* response, vector<byte>* response_payload,
    Callback send_request_callback) {
  bool still_ok = false;
  if (stream_connection().last_read_succeeded()) {
    size_t chunk_size = GetPayloadChunkSize(*response_payload_chunk_buffer_);

    // A chunk size of 0 indicates that the payload has finished, but
    // there may be more headers suffixed to the message. A chunk size
    // of size_t-max is an error value from GetPayloadChunkSize
    // indicating that the size could not be parsed.
    if (chunk_size > 0 && chunk_size < std::numeric_limits<size_t>::max()) {
      Callback response_payload_chunk_received_callback = CreateStrandCallback(
          boost::bind(&HttpClientConnection::ResponsePayloadChunkReceived,
                      this, response, response_payload,
                      send_request_callback));
      still_ok = stream_connection().ReadSize(
          chunk_size, response_payload_chunk_buffer_.get(),
          response_payload_chunk_received_callback);
    } else if (chunk_size == 0) {
      Callback response_payload_post_chunk_header_received_callback =
          CreateStrandCallback(
              boost::bind(
                  &HttpClientConnection::ResponsePayloadPostChunkHeaderReceived,
                  this, response, response_payload, send_request_callback));
      still_ok = stream_connection().ReadUntil(
          { '\r', '\n', }, response_payload_chunk_buffer_.get(),
          response_payload_post_chunk_header_received_callback);
    }
  }

  if (!still_ok) {
    HandleRequestError(response, send_request_callback);
  }
}

void HttpClientConnection::ResponsePayloadChunkSeparatorReceived(
    HttpResponse* response, vector<byte>* response_payload,
    Callback send_request_callback) {
  bool still_ok = false;
  if (stream_connection().last_read_succeeded()) {
    Callback response_payload_chunk_header_received_callback =
        CreateStrandCallback(
            boost::bind(
                &HttpClientConnection::ResponsePayloadChunkHeaderReceived,
                this, response, response_payload,
                send_request_callback));
    still_ok = stream_connection().ReadUntil(
        { '\r', '\n' }, response_payload_chunk_buffer_.get(),
        response_payload_chunk_header_received_callback);
  }

  if (!still_ok) {
    HandleRequestError(response, send_request_callback);
  }
}

void HttpClientConnection::ResponsePayloadChunkReceived(
    HttpResponse* response, vector<byte>* response_payload,
    Callback send_request_callback) {
  bool still_ok = false;

  // Copy partial payload even if the read did not succeed.
  response_payload->insert(response_payload->end(),
                           response_payload_chunk_buffer_->begin(),
                           response_payload_chunk_buffer_->end());

  if (stream_connection().last_read_succeeded()) {
    // There is a line terminator ("\r\n") at the end of each chunk
    // which is not part of the chunk and not counted in the chunk
    // size. Consume this "separator" before attempting to consume the
    // next chunk header.
    Callback response_payload_chunk_separator_received_callback =
        CreateStrandCallback(
            boost::bind(
                &HttpClientConnection::ResponsePayloadChunkSeparatorReceived,
                this, response, response_payload, send_request_callback));
    still_ok = stream_connection().ReadUntil(
        { '\r', '\n' }, serialized_response_.get(),
        response_payload_chunk_separator_received_callback);
  }

  if (!still_ok) {
    HandleRequestError(response, send_request_callback);
  }
}

void HttpClientConnection::ResponsePayloadPostChunkHeaderReceived(
    HttpResponse* response, vector<byte>* response_payload,
    Callback send_request_callback) {
  // If the header is blank (consists only of "\r\n") then this is the
  // end of the transmission. Else, parse this header and look for the
  // next one.
  if (response_payload_chunk_buffer_->size() <= 2) {
    ResponsePayloadReceived(response, response_payload, send_request_callback);
    return;
  } else {
    ParseResponseHeaders(response_payload_chunk_buffer_->begin(),
                         response_payload_chunk_buffer_->end(),
                         response);
    Callback response_payload_post_chunk_header_received_callback =
        CreateStrandCallback(
            boost::bind(
                &HttpClientConnection::ResponsePayloadPostChunkHeaderReceived,
                this, response, response_payload, send_request_callback));
    if (!stream_connection().ReadUntil(
            { '\r', '\n', }, response_payload_chunk_buffer_.get(),
            response_payload_post_chunk_header_received_callback)) {
      HandleRequestError(response, send_request_callback);
    }
  }
}

void HttpClientConnection::ResponsePayloadReceived(
    HttpResponse* response, vector<byte>* response_payload,
    Callback send_request_callback) {
  last_request_succeeded_ = stream_connection().last_read_succeeded();
  CleanUpRequestState();
  if (!last_request_succeeded_) {
    CHECK_NOTNULL(response)->set_transport_succeeded(false);
    Close();
  }
  send_request_callback();
}

void HttpClientConnection::HandleRequestError(
    HttpResponse* response, Callback send_request_callback) {
  last_request_succeeded_ = false;
  CHECK_NOTNULL(response)->set_transport_succeeded(false);
  CleanUpRequestState();
  Close();
  send_request_callback();
}

void HttpClientConnection::CleanUpRequestState() {
  serialized_request_.reset();
  serialized_response_.reset();
  tmp_response_payload_.reset();
  response_payload_chunk_buffer_.reset();
  request_pending_ = false;
}

HttpsClientConnection::HttpsClientConnection()
    : HttpClientConnection(make_unique<SslConnection>()) {
}

HttpsClientConnection::~HttpsClientConnection() {
}

}  // namespace polar_express
